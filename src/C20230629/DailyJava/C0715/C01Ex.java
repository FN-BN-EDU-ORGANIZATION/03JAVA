package C0715;

public class C01Ex {

}
//애플리케이션 테스트 
//: 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차. 확인(Validation)과 검증(Verification)
//
//애플리케이션 테스트의 기본 원리
//- 파레토 법칭(Pareto Principle) : 애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙
//- 살충제 패러독스(Pesticide Paradox) : 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상
//- 오류-부재의 궤변(Absence of Errors Fallacy) : 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없음
//
//애플리케이션 테스트의 분류
//- 프로그램 실행 여부에 따른 테스트
//	- 정적 테스트 : 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트 (워크스루, 인스펙션, 코드 검사)
//	- 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트. 개발 모든 단계에서 테스트 수행 (블랙박스 테스트, 화이트박스 테스트)
//
//- 테스트 기반에 따른 테스트
//	- 명세 기반 테스트 : 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트 (동등 분할, 경계 값 분석)
//	- 구조 기반 테스트 : 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 (구문 기반, 결정 기반, 조건 기반)
//	- 경험 기반 테스트 : 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트 (에러 추정, 체크 리스트, 탐색적 레스팅)
//
//- 시각에 따른 테스트
//	- 검증 테스트(Verification) : 개발자의 시각으로 제품의 생산 과정을 테스트하는 것. 명세서대로 완성됐는지 테스트
//	- 확인 테스트(Validation) : 사용자의 시각으로 생산된 제품의 결과를 테스트하는 것. 사용자가 요구한대로 제품이 완성됐는지 제품이 정상적으로 작동하는지
//
//- 목적에 따른 테스트
//	- 회복(Recovery) 테스트 : 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인
//	- 안전(Security) 테스트 : 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인
//	- 강도(Stress) 테스트 : 과도한 정보량이나 빈도 등을 부과하여 과부하시에도 소프트웨어가 정상적으로 실행되는지 확인
//	- 성능(Performance) 테스트 : 실시간 성능이나 전체적인 효율성을 진단하는 테스트로 소프트웨어의 응답시간, 처리량 등을 테스트
//	- 구조(Structure) 테스트 : 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트
//	- 회귀(Regression) 테스트 : 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
//	- 병행(Parallel) 테스트 : 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트
//
//테스트 기법에 따른 애플리케이션 테스트
//화이트박스 테스트(White Box Test) 
//: 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법. 직접 관찰
//
//화이트박스 테스트
//: 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
//
//화이트박스 테스트의 종류
//- 기초 경로 검사(Base Path Testing) : 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
//- 제어 구조 검사(Control Structure Testing) : 조건 검사(모듈 내에 있는 논리적 조건을 테스트), 루프 검사(반복 구조에 초점을 맞춰 실시하는 테스트), 테이터 흐름 검사(변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트)
//
//화이트박스 테스트의 검증 기준
//- 문장 검증 기준(Statement Coverage) : 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스 설계
//- 분기 검증 기준(Branch Coverage) : 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
//- 조건 검증 기준(Condition Coverage) : 조건문에 포함된 개별 조건식의 결과를 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
//- 분기/조건 기준 (Branch/Condition Coverage) : 분기 검증 기분과 조건 검증 기분을 모두 만족하는 설계. 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스 설계
//
//블랙박스 테스트
//: 각 기능이 완전히 작동되는 것을 입증하는 테스트
//
//블랙박스 테스트의 종류
//- 동치 분할 검사(Equivalence Partitioning Testing) : 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법
//- 경계값 분석(Boundary Value Analysis) : 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 더 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스를 선정하여 검사
//- 원인-효과 그래프 검사(Cause-Effect Graphing Testing) : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 분석하여 다음 효용성이 높은 테스트 케이스를 선정하여 검사
//- 오류 예측 검사(Error Guessing) : 경험이나 확인자의 감각으로 테스트하는 기법
//- 비교 검사(Comparison Testing) : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법
//
//개발 단계에 따른 애플리케이션 테스트
//- 소프트웨어 개발 단계 : 요구사항 -> 분석 -> 설계 -> 구현 
//- 테스트 단계 : 단위 테스트(Unit Testing) -> 통합 테스트(Integration Testing) -> 시스템 테스트(System Testing) -> 인수 테스트(Acceptance Testing)
//
//단위 테스트 : 모듈이나 컴포넌트에 초점을 맞춰 테스트. 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행. 구조 기반 테스트, 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행
//통합 테스트 : 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트. 상호 작용 오류 검사
//시스템 테스트 : 개발된 소프트웨어가 완벽하게 수행하는가를 점검하는 테스트. 기능적 요구사항과 비기능적 요구사항으로 구분
//인수 테스트 : 사용자의 요구사항을 충족하는지에 중점을 두고 테스트. 사용자가 직접 테스트
//	- 사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부를 확인함
//	- 운영상의 인수 테스트 : 백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등 확인
//	- 계약 인수 테스트 : 계약상의 인수/검수 조건을 준수하는지 여부를 확인
//	- 규정 인수 테스트 : 소프트웨어가 정부 지침, 법규, 규정 등 규정에 맞게 개발되었는지 확인함
//	- 알파 테스트 : 사용자가 개발자 앞에서 행하는 테스트. 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록
//	- 베타 테스트 : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법. 실업무를 가지고 사용자가 직접 테스트
//
//통합테스트
//: 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법
//- 비점진적 통합 테스트 : 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방법. 빅뱅 통합 테스트
//- 점진적 통합 테스트 : 모듈 단위로 단계적으로 통합하여 테스트하는 방법. 하양식 통합 테스트, 상향식 통합 테스트, 혼합식 통합 테스트
//
//하향식 통합 테스트 
//: 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
//- 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁(Stub) 으로 대체함
//
//상향식 통합 테스트
//: 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
//- 하위 모듈들을 클러스터(Cluster)로 결합
//- 상위 모듈에서 데이터의 입출력을 확인하기 위해 더미 모듈인 드라이버를 작성함
//
//혼합식 통합 테스트
//: 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식
//
//회귀 테스팅(Regression Testing)
//: 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트
//
//테스트 케이스/테스트 시나리오/테스트 오라클
//- 테스트 케이스(Test Case) : 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 테스트 항목에 대한 명세서
//- 테스트 시나리오(Test Scenario) : 테스트 케이스를 적용하는 순서에 따라 여러개의 테스트 케이스를 묶는 집합
//- 테스트 오라클(Test Oracle) : 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법
//	테스트 오라클의 종류
//	 - 참(True) 오라클 : 모든 테스트 ㅋ이스의 입력값에 대해 기대하는 결과를 제공하는 오라클
//	 - 샘플링(Sampling) 오라클 : 특정 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로 전수 테스트가 불가능한 경우 사용
//	 - 추정(Heuristic) 오라클 : 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
//	 - 일관성 검사(Consistent) 오라클 : 애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클
//
//테스트 자도와 도구 
//- 성능 테스트 도구(Performance Test Tools) : 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인하는 도구
//- 테스트 하네스 도구(Test Narness Tools) : 테스트가 실행될 환경을 시뮬레이션하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구
//	테스트 하네스의 구성 요소
//	 - 테스트 드라이버(Test Driver) : 하위 모듈을 호출하고 파라미터를 전달하고 모듈 테스트 수행 후의 결과를 도출하는 도구
//	 - 테스트 스텁(Test Stub) : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
//  
//애플리케이션 성능 분석
//: 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도
//- 처리량(Throughput) : 일정 시간 내에 애플리케이션이 처리하는 일의 양
//- 응답 시간(Response Time) : 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
//- 경과 시간(Turn Around Time) : 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
//- 자원 사용률(Resource Usage) : 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률
//
//애플리케이션 성능 개선
//- 소스 코드 최적화 : 나쁜 코드를 배제하고 클린 코드로 작성하는 것
//
//클린코드 작성 원칙
//- 가독성 : 누구든지 코드를 쉽게 읽을 수 있도록 작성. 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용
//- 단순성 : 코드를 간단하게 작성. 한번에 한가지를 처리하도록 ㅗ드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리
//- 의존성 배제 : 코드가 다른 모듈에 미치는 영향을 최소화함. 코드 변셩 시 다른 부분에 영향이 없도록 작성
//- 중복성 최소화 : 코드의 중복을 최소화. 중복된 코드는 삭제하고 공통된 코드를 사용
//- 추상화 : 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고 상세 내용은 하위 클래스/메소드/함수에서 구현
//
//소스 코드 품질 분석
//- 정적 분석 도구(Static Analysis) : 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인
//- 동적 분석 도구(Dynamic Analysis) : 작성한 소스 코드를 실행하여 코드의 존재하는 메모리 누수, 스레드 결함 등을 분석
//
//소스 코드 품질 분석 도구의 종류
//- pmd : 소스 코드에 대한 미사용 변수, 최적화되지 않은 코드 등 결함을 유발할 수 있는 코드 검사(Linux, Windows)
//- cppcheck : c/c++ 코드에 대한 메모리 누수, 오버플로우 등 분석(windows)

















