package 이헌지;

//public class D4 변수의타입 
//
//값(date)의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형(date type)이다.
//자료형에는 
//    문자형(char),
//    정수형(byte,short,int,long)
//    실수형(float,double) 
//    등이 있음,변수를 선언할 때는 저장하려는 값의 특성을 고려하여 가장 알맞음 자료형을 변수의 타입으로 선택하면 된다.
//
//기본형과 참조형
//

//기본형(primitive type)   실제값(data)을 저장 

//논리형(boolean),문자형(char),정수형(byte,short,int,long),실수형(float,double)
//계산을 위한 실제 값을 저장한다. 모두8개

//참조형(reference type)    어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다.

//객체의 주소를 저장한다.8개의 기본형을 제외한 나머지 타입.

//자바는 c언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수
//참조형 변수(또는 참조변수)를 선언할 떄는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다.
//그래서 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.

//다음은 참조변수를 선언하는 방법이다.기본형 변수와 같이 변수이름 앞에 타입을 적어주는데 참조변수의 타입은 클래스의 이름이다.

//클래스이름 변수이름; //변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다.

//Date today = new Date();  Date객체를 생성해서, 그 주소를 today에 저장


//2.1기본형(primitive type)

//기본형에는 모두8개의 타입(자료형)이 있으며,크게 논리형,문자형,정수형,실수형으로 기본된다.

//분류    |                타입                                           
//논리형     boolean:true와 false중 하나를 값으로 갖으며,조건식과 논리적 계산에 사용된다. 
//문자형     char   :문자를 저장하는데 사용되며,변수에 하나의 문자만 저장할 수 있다.
//정수형     byte,short,int,long:정수를 저장하는데 사용되며,주로 int가 사용된다.
//     byte는 이진 데이터를 다룰 때 사용되며,short은 C언어와의 호환을 위해서 추가되었다.
//실수형     float,double :실수를 저장하는데 사용되며,주로 double이 사용된다.

//문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 떄문에 정수형과 별반 다르지 않으며,정수형 또는 실수형과
//연산도 가능하다. 반면에 boolean은 다른 기본형과의 연산이 불가능하다.즉,boolean을 제외한 나머지 7개의 기본형은
//서로 연산과 변환이 가능하다.  정수는 가장많이 사용되므로 타입을 4가지나 제공한다. 각 타입마다 저장할 수 있는 값의 범위가
//다르므로 저장할 값의 범위에 맞는 타입을 선택하면 되지만,일반적으로 int값의 범위가 다르므로 저장할 값의 범위에 맞는 타입을
//선택하면 되지만,일반적으로 int를 많이 사용한다.왜냐하면.int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다.
//효율적인 실행보다 메모리를 절약하려면. byte나 short을 선택하자

//|참고| 4개의 정수형(byte,short,int,long)중에서 int형이 기본 자료형(default data type)이며, 
//실수형(float,double)중에서는 double이 기보 자료형이다.

//   1byte      2byte    4byte    8 byte  
//논리형   boolean 
//문자형              char
//정수형    byte      short     int       long
//실수형                       float     double

//* boolean은 true와 false 두 가지 값만 표현할 수 있으면 되므로 가장 작은 크기인 1byte
//* char은 자바에서 유니코드(2 byte 문자체계)를 사용하므로 2 byte.
//* byte는 크기가 1byte라서 byte.
//* int(4byte)를 기준으로 짦아서 short(2 byte).길어서 long(8byte).(short <-> long)
//* float는 실수값을 부동소수점(floating-point)방식으로 저장하기 떄문애 float.
//* double은 float보다 두 배의 크기(8byte)를 갖기 떄문에 double.

//2.2 상수와 리터럴(constant & literal)
//'상수(constant)'는 변수와 마찬가지로 '값을 저장할 수 있는 공간' 이지만
//,변수와 달리 한 번 값을 저장하면 다른 값으로 변경할 수 없다.
//상수를 선언하는 방법은 변수와 동일하며,단지 변수의 타입 앞에 키워드'final'을 붙여주기만 하면 된다.

//final int MAX_SPEED = 10;   //상수 MAX_SPEED를 선언 & 초기화

//그리고 상수는 반드시 선언과 동시에 초기화해야 하며,그 후 부터는 상수의 값을 변경하는 것이 허용되지 않는다.

//final int MAX_SPEED;       //에러. 상수는 선언과 동시에 초기화해야함 
//final int MAX_VALUE = 100; //OK. 선언과 동시에 초기화했음
//MAX_VALUE = 200;           //에러. 상수의 값은 변경할 수 없음
//
//상수의 이름은 모두 대문자로 하는 것이 암묵적인 관례이며,여러 단어로 이루어져있는 경우'_'로 구분한다.
//
//리터럴(literal)
//원래 13,123,3.14,'a'와 같은 값들이 '상수'인데, 
//프로그래밍에서는 상수를 '값을 한 번 저장하면 변경할 수 없는 저장공간'으로 정의하였기 때문에 이와 구분하기 위해
//상수를 다른 이름으로 불러야만 했다. 그래서 상수 대신 리터럴이라는 용어를 사용한다. 많은 사람들이 리터럴이라는 용어를
//어려워 하는데,리터럴은 단지 우리가 기존에 알고 있던'상수'의 다른 이름일 뿐이다.

//변수(variable) : 하나의 값을 저장하기 위한 공간
//상수(constant) : 값을 한번만 저장할 수 있는 공간 
//리터럴(literal) : 그자체로 값을 의미하는 것

// int year(변수) = 2014;(리터럴)
// final int MAX_VALUE(상수) = 100;(리터럴)

//상수가 필요한 이유 

//int triangleArea = (20 * 10) / 2;  //삼각형의 면적을 구하는 공식
//int rectangleArea = 20 * 10 ;      //사각형의 면적을 구하는 공식 

//위의 코드는 삼각형과 사각형의 면적을 구해서 변수에 저장한다. 이 공식을 모르는 사람은 없겠지만,보다 복잡한 공식이라면 얘기가 
//달라질 것이다. 게다가 20과 10이 아닌 다른 값을 이용해서 결과를 얻고 싶다면 여러 곳을 수정해야한다.
//그러면 이제 다음의 코드를 보자

//final int WIDTH = 20; //폭
//final int HEIGHT = 10; //높이

//int triangleArea = (WIDTH * HEIGHT)   / 2;  //삼각형의 면적을 구하는 공식 
//int rectangleArea = WIDTH * HEIGHT ;        //사각형의 면적을 구하는 공식

//상수를 이용해서 기존의 코드를 변경한 것인데,이전 코드에 비해 면적을 구하는 공식의 의미가 명확해 졌다.
//그리고 다른 값으로 계산할 떄도 여러 곳을 수정할 필요없이 상수의 초기화만 다른 값으로 해주면 된다.
//이처럼 상수는 리터럴에'의미있는 이름'을 붙여서 코드의 이해와 수정을 쉽게 만든다.

//리터럴의 타입과 접미사 
//변수에 타입이 있는 것처럼 리터럴에도 타입이 있다. 변수의 타입은 저장될'값의 타입(리터럴의 타입)'에 의해 결정되므로,
//만일 리터럴에 타입리 없다면 변수의 타입도 필요없을 것이다.

//|    종류    |         리터럴                |   접미사 |
//|  논리형     | false,true                  |   없음   | 
//|  정수형     |123, 0b0101, 0xFF ,100L      |   L     |
//|  실수형     |3.14, 3.0e8, 1.4f, 0x1.0p-1  |   f,d   |
//|  문자형     |'A','1','\n'                 |   없음    |
//|  문자열     |"ABC","123","A","true"       |   없음    |

//정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 접미사를 붙여서 타입을 구분한다. 정수형의 경우,long타입의
//리터럴에 접미사 'l' 또는 'L'을 붙이고, 접미사가 없으면 int타입의 리터럴이다. byte와 short타입의 리터럴은별도로 
//존재하지 않으며 byte와 short타입의 변수에 값을 저장할 때는 int타입의 리터럴을 사용한다.
//10진수 외에도 2,8.16진수로 표현된 리터럴을 변수에 저장할 수 있으며, 16 진수라는 것을 표시하기 위해 
//리터럴 앞에 접두사'0x'또는'0X'를,8진수의 경우에는 '0'을 붙인다.

//|참고|접두사'0x','0X','0b','0B','0'의 '0'은 알파벳이 아니라 숫자이다.2진 리터럴은 JDK 1.7부터 추가되었다.

//int octNum = 010;            //  8진수 10, 10진수로 9
//int hexNum = 0x10;            // 16진수 10, 10진수로 16
//int binNum = 0b10;            //  2진수 10, 10진수로 2

//그리고 JDK 1.7부터 정수형 리터럴의 중간에 구분자'_'를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있게 되었다.

//long big = 100_000_000_000L;               // long big = 100000000000L;
//long hex = 0xFFFF_FFFF_FFFF_FFFFL;         // long hex = 0xFFFFFFFFFFFFFFFFL;

//실수형에서는 float 타입의 리터럴에 접미사'f'또는'F'를 붙이고,double타입의 리터럴에는 
//접미사'd'또는'D'를 붙인다.

//float  pi      = 3.14f;         // 접미사 f 대신 F를 사용해도 된다.
//double rate    = 1.618d;        // 접미사 d 대신 D를 사용해도 된다.

//실수형 리터럴에는 접미사를 붙여서 타입을 구분하며,float타입 리터럴에는'f'를,double타입 리터럴에는'd'를 붙인다.
//정수형에서는 int가 기본 자료형인 것처럼 실수형에서는 double이 기본 자료형이라서 접미사'd'는 생략이 가능하다.
//실수형 리터럴인데,접미사가 없으면 double타입 리터럴인 것이다.

//float   pi  = 3.14;  //에러.float타입 변수에 double타입 리터럴 저장불가
//double rate = 1.618; //OK. 접미사 d는 생략할 수 있다.

//위의 문장에서 3.14는 접미사가 붙지 않았으므로 float타입 리터럴이 아니라 double타입 리터럴로 간주된다.
//그래서 3.14가 float타입의 범위에 속한 값임에도 불구하고 컴파일 시에 에러가 발생한다.
//에러를 피하려면 3.14f와 같이접미사를 붙여야 한다. 리터럴의 접두사와 접미사는 대소문자를 구별하지 않으므로,
//대문자와 소문자 중에서 어떤 것을 사용해도 상관없지만,소문자'l'의 경우 숫자'1'과 헷갈리기 쉬우므로 대문자인 
//'L'을 사용하는 것이 좋다.

//|참고|리터럴에 접미사가 붙는 타입은 long,float,double뿐인데,double은 생갹가능하므로 long과 float의 
//리터럴에 접미사를 붙이는 것만 신경쓰면 된다.

//리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e,그리고 접미사 f,F,d,D를 포함하고 있으면 실수형 리터럴로 간주

//                실수형 리터럴의 예

//    자료형     |   실수형 리터럴    |다른 형태의 동등한 표현|
//  double     |      10.      |      10.0      |
//  double     |      .10      |      0,10      |
//   float     |      10f      |      10.0f     |
//   float     |    3.14e3f    |     3140.0f    |
//  double     |      1e1      |      10.0      |
//  double     |     le-3      |      0.001     |

//참고로 잘 쓰이지는 않지만 기호 p를 이용해서 실수 리터럴을 16진 지수형태로 표현할 수도 있다.p는 2의 제곱을 의미하며,
//p의 왼쪽에는 16진수를 적고 오른쪽에는 지수를 10진 정수로 적는다.
//p는 대소문자 모두 가능하며,p가 포함된 리터럴은 실수형이다.

//0x1p1     =(1x16^0)x2^1           =1.0 x 2        = 2.0
//0x0.2p-1  =(2x16^-1)x2^ 	-1         =0.125 x 0.5    = 0.0625
//0x12p3    =(1x16^1 + 2x16^0)x2^3  =(16+2) x 8     = 144.0

//타입의 불일치
//리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만,타입이 달라도 저장범위가 넒은 타입에 좁은 타입의 값을
//저장하는 것은 허용된다.

//int    i = 'A';      //OK. 문자'A'의 유니코드인 65가 변수 i에 저장된다.
//long   i = 123;      //OK. int보다 long타입이 더 범위가 넒다.
//double d = 3.14f;    //OK. float보다 double타입이 더 범위가 넒다.

//그러나 리터럴의 값이 변수의 타입의 범위를 넘어서거나,리터럴의 타입이 변수의 타입보다 저장범위가 넒으면 컴파일 에러가 발생

//int     i = 0x123456789;     // 에러. int타입의 범위를 넘는 값을 저장
//float   f = 3.14;            // 에러. float 타입보다 double 타입의 범위가 넒다.

//3.14는 3.14d에서 접미사가 생략된 것으로 double타입이다.이 값을 float타입으로 표현할 수 있지만,
//double타입의 리터럴이므로 float타입의 변수에 저장할 수는 없다.

//|참고| floa는 접미사나 정밀도 등 신경 쓸 것이 많다.이런 것들이 귀찮다면 그냥 double을 사용하자.

//byte와 short타입의 리터럴은 따로 존재하지 않으므로 int타입의 리터럴을 사용한다.
//단,short타입의 변수가 저장할 수 저장할 수 있는 범위에 속한 것이어야 한다.

//byte b  = 65;       //OK. byte타입에 저장 가능한 범위의 int타입 리터럴 
//short s = 0x1234;   //OK. short타입에 저장 가능한 범위의 int타입 리터럴

//각 타입의 저장범위만 알아도 충분히 판단가능한 내용이다.값의 크기에 상관없이 double타입의 리터랄을 float타입의 
//변수에 저장할 수 없다는 것만 주의하자. 보다 자세한 내용은 이 장의 마지막 단원인 '형변환'에서 설명한다.

//문자 리터럴과 문자열 리터럴
//'A'와 같이 작은따옴표로 문자 하나늘 감싼 것을 '문자 리터럴'이라고 한다. 
//두 문자 이상은 큰 따옴표로 감싸야 하며 '문자열 리터럴'이라고 한다

//|참고|문자열은 '문자의 연속된 나열'이라는 뜻이며,영어로 'String'이라고 한다.

//char   ch    = 'J';        //char ch = 'JAVA'; 이렇게 할 수 없다.
//String name  = "JAVA"      //변수 name에 문자열 리터럴 "JAVA"를 저장 

//char타입의 변수는 단 하나의 문자만 저장할 수 있으므로,여러 문자(문자열)를 저장하기 위해서는 String타입을 사용해야 한다.
//문자열 리터럴은 ""안에 아무런 문자도 넣지 않는 것을 허용하며, 이를 빈 문자열(empty string)이라고 한다.
//그러나 문자 리터럴은 반드시 "안에 하나의 문자가 있어야한다.

//String str = "";        //OK. 내용이 없는 빈 문자열 
//char   ch  = '';        //에러. ''안에 반드시 하나의 문자가 필요  
//char   ch  = ' ';       //OK. 공백 문자(blank)로 변수 ch를 초기화

//원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히 위와 같은 표현도 허용한다.

//String name = new String("JAVA"); // String객체를 생성 

//그리고 덧셈 연산자를 이용하여 문자열을 결합할 수 있어서 다음과 같이 할 수 있다.

//String name = "Ja" + "va";   // name은 "JAVA"
//String str  = name + 8.0;    // str은 "JAVA8.0"

//덧셈 연사자(+)는 피연산자가 모두 숫자일 떈 두 수를 더하지만,피연산자 중 어느 한쪽이 String이면 나머지 한쪽을 먼저 
//String으로 변환한 다음 두 String을 결합한다. 기본형가 참조형의 구별 없이 어떤 타입의 변수도 문자열과 덧셈연산을 
//수행하면 그 결과가 문자열이 되는 것 이다.
//문자열 +any type-> 문자열 + 문자열 -> 문자열
//any type + 문자열 -> 문자열 + 문자열 ->문자열
//예를 들어 7+"7"을 계산할 떄 7이 String이 아니므로,먼저 7을 String으로 변환한 다음 "7"+"7"을 수행하여 "77"을 결과로 얻는다.
//다음은문자열 결합의 몇 가지 예를 보여준다.

//7 + " " → "7" + " " → "7 "
//" " + 7 →  " " + "  → " 7"

//7 + "7" → "7" + "7" → "77"

//7 + 7 + " " → 14 + "" → "14" +"" → "14" 
//"" + 7 + 7 → "7" + 7 → "7" + "7" →"77"

//true + "" → "true" + "" → "true"
//null + "" → "null" + "" → "null"

//덧셈 연산자는 왼쪽에서 오른쪽의 방향으로 연산을 수행하기 때문에 결합순서에 따라 결과가 달라진다는 것에 주의하자.
//그리고 7과 같은 기본형 타입의 값을 문자열로 변환할 때는 아무런 내용도 없는 빈 문자열("")을 더해주면 된다는 것도 알아두자.

