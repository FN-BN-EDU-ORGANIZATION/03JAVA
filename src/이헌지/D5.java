// 3.진법 
// 3.1 10진법과 2진법
// 우리는 일상생활에서 주로 사용하는 것은 10진법이다. 아마도 사람이 10개의 손가락을 가지고 있기 떄문 아닐까.
// 194년에 개발된 컴퓨터인 에니악(ENIAC)은 사람에게 익숙한 10진법을 사용하도록 설계되었으나 전기회로는 전압이 불안정해서 전압을
// 10단계로 나누어 처리하는데 한계가 있었다.그래서 1050년에 개발된 에드박(EDVAC)은 단 두가지 단계,전기가 흐름면1,흐르지 않으면0,만으로
// 동작하도록 설계되었고 매우 성공적이었다. 손가락의 개수가 10인 사람에게 10진법이 적합하듯,컴퓨터와 같은 전기회로에는 2진법이 적합한 것이다.
// 그 이후부터 지금까지 대부분의 컴퓨터는 2진 체계로 설계되었기 때문에, 2진법을 알지 못하면 컴퓨터의 동작원리나 데이터 처리방식을
// 온전히 이해할 수 없다.지금까지 변수에 값을 저장하면 10진수로 저장되는 것처럼 설명을 하였지만,컴퓨터는 2진수(0과1) 밖에 모르기 떄문에
// 아래의 오른쪽과 같이 2진수로 바뀌어 저장된다. 2진수 11001은 10진수로 25이다.

//     int age = 25; //변수 age에 25를 저장
//     age25 → age 11001
// |참고| int타입의 크기가 4byte면,32자리의 2진수로 표현해야지만 앞의 0은 생략하였다. 0을 생략하지않으면.
// '11001'이 아니라 '00000000000000000000000000011001'이다.

// 이처럼 2진법은 0과 1로만 데이터를 표현하기 떄문에 10진법에 비해 많은 자리수를 필요로 한다. 10진수 2와 같이 작은 숫자도 
// 2진수로 표현하려면 2자리가 필요하다. 2진수 한자리로는 1보다 큰값을 표현할 수 없기 떄문이다.
// 이것은 10진수에서 9보다 큰 수를 표현하기 위해서는 두 자리의 10진수가 필요한 것과 같다.

// 3.2 비트(bit)와 바이트(byte)
// 한자리의 2 진수를 '비트(bit, binary digit)'라고 하며, 1비트는 컴퓨터가 값을 저장할 수 있는 최소단위이다.
// 그러나 1 비트는 너무 작은 단위이기 떄문에 1비틀 8개를 묶어서 '바이트(byte)' 라는 단위로 정의해서 데이터의 기본 단위로 사용한다.

// 0 bit
// 00000000 byte(=8 bit)
// [       ][       ][       ][       ] word(=4 byte)

// 이 외에도 '워드(word)'라는 단위가 있는데 '워드(word)'는 'CPU가 한 번에 처리할 수 있는 데이터의 크기'를 의미한다. 
// 워드의 크기를 4바이트(32 비트)라고 헀지만,사실 워드의 크기는 CPU의 성능에 따라 달라진다. 예를 들어 32 비트 CPU에서 
// 1워드는 32비트(4 바이트)이고,64비트 CPU애서는 64비트(8 바이트)이다.
// |참고| nibble: 4bit,16진수 1자리(2진수 4자리)를 저장할 수 있는 단위

// 3.3 8진법과 16진법
// 2진법은 오직 0과,1 두 개의 기호만으로 값을 표현하기 때문에,2진법으로 값을 표현하면 자리수가 상당히 길어진다는 단점이 있다.
// 이러한 단점을 보완하기 위해 2진법 대신 8진법이나 16진법을 사용한다.
// 8진수는 2진수 3자리를,16진수는 2진수 4자리를 각각 한자리로 표현할 수 있기 때문에 자리수가 짦아져서 알아보기 쉽고 
// 서로간의 변환방법 또한 매우 간단하다.
// 8진법은 값을 표현하는데 8개의 기호가 필요하므로 0~7의 숫자를 기호로 사용하면 되지만,16진법은 16개의 기호가 필요하므로 0~9의 
// 숫자만으로는 부족하다. 그래서 6개의 문자(A~F)를 추가로 사용한다. 예를 들어 16진수 A는 10진수로 10이고,F15이다.

//2진수를 8진수,16진수로 변환
// 2진수를 8진수로 변환하려면,2진수를 뒤에서부터 3자리씩 끊어서 그에 해당하는 8진수로 바꾸면 된다. 8은2^3이기 떄문에,9진수 한 자리가
// 2진수 3자리를 대신할 수 있는 것이다. 2진수를 16진수로 변환하는 방법 역시 이와 비슷한데,3자리가 아닌 4자리씩 끊어서 바꾼다는 점만 다르다.

// 3.4 정수의 진법 변환 

// 10진수를 n진수로 변환
// 10진수를 다른 진수로 변환하려면,해당 진수로 나누고 나머지 값을 옆에 적는 것을 더 이상 나눌 수 없을 때까지 반복한 다음 마지막 몫과
// 나머지를 아래부터 위로 순서대로 적으면 된다.

// n진수를 10진수로 변환
// 어떤 진법의 수라도 10진수로 변환하는 방법은 똑같다. 각 자리의 수에 해당 단위의 값을 곱해서 모두 더하면 된다. 

// 3.5 실수의 진법변환
// 10진 소수점수를 2진 소수점수로 변환하는 방법
// 10진 소수점수를 2진 소수점수로 변환하는 방법은 10진 소수점수에 2를 계속 곱하면 된다.

// 3.6 음수의 2진 표현 - 2의 보수법
// 앞서 살펴본 것과 같이 n비트의 2진수로 표현할 수 있는 값의 개수는 모두 2^n개이므로,4비트의 2진수로는 모두2^4(=16)개의 값을 표현할 수 있다.

// 2의 보수법 
// 어떤 수의'n의 보수'는 더했을 때 n이 되는 수를 말한다. 7의 '10의 보수'는 3이고,3의 '10의 보수'는 7이다. 
// 3과 7은 '10의 보수의 관계'에 있다고 한다. '2의 보수 관계'역시,더해서 2가 되는 두 수의 관계를 말하면 10진수 2는 2진수로 '10' 이다.
// 2진수로 '10'은 자리올림이 발생하고 0이 되는 수를 뜻한다.그래서 '2의 보수 관계'에 있는 두 2진수를 더하면'(자리올림이 발생하고)0이 된다.'

// 음수의 2진 표현을 구하는 방법
// (1)음수의 절대값을 2진수로 변환한다.
// :-5의 절대값인 5를 2진수로 변환한다. 10진수 5를 2진수로 변환하면 '0101'이다.
// (2)(1)에서 구한 2진수의 1을 0으로 0은 1로 바꾼다.(1의 보수 구하기)
// :'0101'이 '1010'이 된다.
// (3)의 결과에 1을 더한다.(2의 보수 구하기,1의 보수 + 1)
// :'1010' 1을 더하면 '1011'이 되고,이것이 -5의 2진 표현이다.

// 4. 기본형 (primary type)
// 이번 단원에서는 기본형의 보다 세부적인 내용에 대해 살펴볼 것이다. 다소 깊이 있는 내용이므로 어렵다고 느낄 수도 있는데,앞서 배운 기본형에
// 대한 대략적인 내용만으로도 별 부족함 없이 진도를 나갈 수 있으니까 다 이해하지 못해도 괜찮다. 그래도 언젠가는 반드시 
// 알아야하는 내용이므로 가볍게 라도 봐둘 필요는 있다.

// 4.1 논리형 - boolean
// 논리형에는 'boolean' 한가지 밖에 없다. boolean형 변수에는 true와 false 중 하나를 저장할 수 있으며 기본값(default)은 false이다.
// boolean형 변수는 대답(yes/no,스위치(on,off)등의 논리구현에 주로 사용된다. 그리고 boolean형은 true와false, 두 가지 값만을 
// 표현하면 되므로 1 bit만으로도 충분하지만,자바에서는 데이터를 다루는 최소단위가 byte이기 때문에,boolean의 크기가 1 byte 이다.
// 아래 문장은 power라는 boolean형 변수를 선언하고 true로 변수를 초기화 했다.

// boolean power   =  true;   
// boolean checked =  False;    //에러. 대소문자가 구분됨. true 또는 false만 가능

// 자바에서는 대소문자가 구별되기 떄문에 TRUE와 true는 다른 것으로 간주된다는 것에 주의하자.

// 4.2 문자형 - char
// 문자형 역시'char'한 가지 자료형 밖에 없다. 문자를 저장하기 위한 변수를 선언할 때 사용되며,char타입의 변수는 단 하나의 문자만을 
// 저장할 수 있다. 아래의 문장은 char 타입의 변수 ch를 선언하고,문자'A'로 초기화한다.

//  char ch = 'A';   // 문자 'A'를 char타입의 변수 ch에 저장.

// 위의 문장은 변수에 '문자'가 저장되는 것 같지만, 사실은 문자가 아닌 '문자의 유니코드(정수)'가 저장된다. 컴퓨터는 숫자 밖에 모르기 떄문에
// 모든 데이터를 숫자로 변환하여 저장하는 것이다. 문자'A'의 유니코드는 65이므로,변수 ch에는 65가 저장된다.
// 그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.문자'A'의 유니코드는 10진수로 65이며,아래의 두 문장은 동일한 결과를 얻는다.

//  char ch = 'A'  //문자 'A'를 char타입의 변수 ch에 저장.
//  char ch = 65;  //문자의 코드를 직접 변수 ch에 저장

//만일 어떤 문자의 유니코드를 알고 싶으면,char형 변수에 저장된 값을 정수형(int)으로 변환하면 된다.


//  int code = (int)ch;    // ch에 저장된 값을 int타입으로 변환하여 저장한다.

// 어떤 타입(type,형)을 다른 타입으로 변환하는 것을 형변환(캐스팅,casting)이라고 하는데,형변환에 대해서는 이 장의 마지막에 자세히 
// 설명할 것이다. 지금은 문자의 유니코드를 알아내는 방법과,어떤 유니코드가 어떤 문자를 나타내는가를 알아내는 방법이 있다는 것만 이해하고 넘어가자.

// char hch = 0xAc00;            // char hch = '가'
// char hch = '\uAC00';          // 이렇게도 가능

// 특수 문자 다루기 
// 영문자 이외에 tab이나 backspace 등의 특수문자를 저장하려면, 아래와 같이 조금 특별한 방법을 사용한다.
// 't'sms 실제로는 두 문자로 이루어져 있지만 한 문자(탭, tab)를 의미한다. 아래의 표는 (tab)과 같이 특수한 문자를 어떻게 표현할 수 있는지 알려준다.

//         특수 문자            |          문자 리터럴                     
//       tab                     \t
//       backspace            |  \b
//       form lead            |  \f
//       new lint             |  \n
//       carriage return      |  \r                                      // 특수문자 표현방법표
//       역슬래쉬(\)             | \\
//       작은따옴표               |  \'
//       큰따옴표                 |  \"
//       유니코드(16진수)문자        |  \u유니코드(예:char a='\u0041')        

// char 타입의 표현형식

// char타입의 크기는 2 byte(=16 bit)이므로,16자리의 2진수로 표현한 수 있는 정수의 개수인 65536개(=2^16)의 코드를 사용 할 수 있으며 ,
// char형 변수는 이범위 내의 코드 중 하나를 저장할 수 있다. 예를 들어, 문자 'A'를 저장하면, 아래와 같이 2진수 '0000000001000001'(10진수로 65)로 저장된다.
// char 타입은 문자를 저장할 변수를 선언하기 위한 것이지만,실제로 char타입의 변수에는 문자가 아닌 '문자의 유니코드(정수)'가 저장되고 표현형식 역시 정수형과 동일하다.
// 다만,정수형과 달리 음수를 나타낼 필요가 없으므로 표현할 수 있는 값의 범위가 다르다. 
// 2 byte(16= bit)로는 모두 2^16(=65536)개의 값을 표현할 수 있는데,char타입에 저장 되는 값인 유니코드는 모두 양수(0 포함)이므로,
// '0~65536'의 범위를 가지며, 정수형인 'Short'은 절반을 음수표현에 사용하므로 '-32768~32767'을 범위로 갖는다.

// 16비트로 표현할 수 있는 정수의 개수:2^16개(65536개)
// short타입의 표현범위:-2^15 ~ 2^15-1(-32768~32767)
// char타입의  표현범위:0 ~ 2 -1(0~65536)
// 
  