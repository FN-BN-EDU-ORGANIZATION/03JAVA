package C02.변수;

// 2.변수의 타입
// 우리가 주로 사용하는 값(date)의 종류(type)는 크게 '문자와 숫자'로 나눌 수 있으며,숫자는 다시'정수롸 실수'로 나눌 수 있다.
/*
     ↗ 문자 ('A'.'1',"ABC")
     
  값 
          ↗ 정수 (123.0,-100) -> 0을 포함 ex)양의 정수,음의 정수
     ↘ 숫자  
          ↘ 실수 (3.14,-3.0x10^8) ->수직선상의 모든수 
*/
// 이러한 값(data)의 종류(type)에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형(data type)이다.
// 자료형에는 문자형(char),정수형(byte, short,int,long),실수형(float,double)등이 있으며,변수를 선언할 때는 
// 저장하려는 값의 특성을 고려하여 가장 알맞은 자료형을 변수의 타입으로 선택하면 된다.

// 기본형과 참조형
// 자료형은 크게 '기본형' 과 '참조형' 두 가지로 나눌 수 있는데,기본형 변수는 실제 값(data)를 저자하는 반면,
//참조형 변수는 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다.

// |참고| 메모리에는 1byte단위로 일련번호가 붙어있는데,이 번호를 '메모리 주소(memory address)'또는 간단히 '주소'라고 한다.
// 객체의 주소는 객체가 정장된 메모리 주소를 뜻한다.
/*
  기본형(primary type)
  - 논리향(boolean),문자형(char),정수형(byte,short,long),실수형(float,double) 계산을 위한 실제 값을 지칭한다. 모두 8개
  
  참조형(refernce)
  - 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입
*/
// 참조형 변수(또는 참조변수)를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다.
// 그래서 새로운 클래스를 작성한다는 것은 새로운 참조형 추가하는 셈이다.
// 다음은 참조변수를 선언하는 방법이다. 기본형 변수와 같이 변수이름 앞에 타입을 적어주는데 참조변수의 타입은 클래스의 이름이다.

// 클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다.

// 다음은 Data클래스 타입의 참조변수 today를 선언한 것이다. 참조변수는 null또는 객체의 주소를 값으로 갖으면 참조변수의 초기화는 다음과 같이 해야한다.

// Date today = new Date(); //Date객체를 생성해서,그 주소를 today에 저장

// 객체를 생성하는 연산자 new의 결과는 생성된 객체의 주소이다. 이주소가 대입연산자'='에 의해서 참조변수 today에 저장되는 것이다.
// 이제 참조변수 today를 통해서 생성된 객체를 사용할 수 있게 된다.

// |참고| 참조형 변수는 null또는 객체의 주소(4 byte,0x0~0xFFFFFFFF)를 값으로 갖는다.
// null은 어떤 객체의 주소도 저장되어 있지 않음을 뜻한다. 단,JVM이 32bit가 아니라 64bit라면 참조형 변수의 크기는 8byte가 된다.

// Q.자료형(data type)과 타입(type)의 차이가 뭔가요?
// A.기본형은 저장할 값(data)의 종류에 따라 구분되므로 기본형의 종류를 얘기할 때는 '자료형(data type)'이라는 용어를 씁니다.
// 그러나 참조형은 항상 '객체의 주소(4 byte 정수)'를 저장하므로 값(data)이 아닌,객체의 종류에 의해 구분되므로 참조형 변수의 종류를 구분할 때는
// '타입(type)'이라는 용어를 사용합니다.'타입(type)'이 '자료형(data type)'을 포함하는 보다 넒은 의미의 용어이므로 굳이 구분하지 않아도 됩니다.

// 2.1 기본형(primitive type)
// 기본형에는 모두 8개의 타입(자료형)이 있으며,크게 논리형,문자형,정수형,실수형으로 구분된다.

/*    분류    |                    타입
     ____________________________________________________________
     논리형    |boolean        
             |true와 false 중 하나를 값으로 갖으며,조건식과 논리적 계산에 사용된다.
     ____________________________________________________________
     문자형    |char
             |문자를 저장하는데 사용되면,변수에 하나의 문자만 저장할 수 있다.
     ____________________________________________________________
     정수형    |byte,short,int,long
             |정수를 저장하는데 사용되며,주로 int가 사용된다.byte는 이진테이터를 다룰때 사용되며,short는 C언어와의 호환성을 위해 추가되었다
     __________________________________________________________________________________________________
     실수형    |float,double 
             |실수를 저장하는데 사용되며 주로 double이 사용된다.
             
             ▲ 표 2-2 기본형의 종류
*/
// 문자형인 char는 무자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 않으며, 정수형 또는 실수형과 연산도 가능하다.
// 반면에 boolean은 다른 기본형과의 연산이 불가능하다. 즉,boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.
// 정수는 가장 많이 사용되므로 타입을 4가지나 제공한다. 각 타입마다 저장할 수 있는 값의 범위가 다르므로 저장할 값의 버위에 맞는 타입을 선택하면 되지만,
// 일반적으로 int를 많이 사용한다. 왜냐하면,int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다.
// 효율적인 실행보다 메모리를 절약하려면,byte나 short를 선택하자.

// |참고| 4개의 정수형(byte,short,int,long)중에서 int형이 기본 자료형(defalut data type)이며, 
// 실수형(float,double)중에서는 double이 기본 자료형이다.
/*
             
     종류형 \ 크기   | 1byte | 2byte | 4byte | 8byte 
     ___________ |_______|_______|_______|________
     논리형        |boolean|
     문자형        |       | char  |
     정수형        | byte  | short |  int  |  long   
     실수형        |       |       | float | double
*/
//                  ▲ 표 2-3 기본형의 종류와 크기  

// 기본 자료형의 종류와 크기는 반드시 외워야 하며, 아래의 문장들이 도움이 될 것이다.
/*
   ▶ boolean은 true와 flase 두 가지 값만 표현할 수 있으면 되므로 가장 작은 크기인 1byte.
   ▶ char은 자바에서 유니코드(2 byte 문자체계)를 사용하므로 2 byte.
   ▶ byte는 크기가 1byte라서 byte.
   ▶ int(4 byte)를 기준으로 짦아서 short(2 byte),길어서 long(8 byte),(short ↔ long)
   ▶ float는 실수값을 부동소수점(floating-point)방식으로 저장하기 때문에 float.
   ▶ double은 float보다 두 배의 크기(8byte)를 갖기 때문에 double.
*/
// 그리고 각 타입의 변수가 저장할 수 있는 값의 범위는 다음과 같다.
/*
   자료형      |                          저장 가능한 값의 범위                              |     크기 
  ___________|___________________________________________ ___                       |__bit | byte|
  boolean    |                            false,true                                |  8   |  1  |
  char       |               '\u0000'~'\uffff'(0~2^16-1,0~65535)                    |  16  |  2  |
  byte       |                      -128~ 127(-2^7~2^7-1)                           |  8   |  1  | 
  short      |                    -32,768 ~ 32,767(-2^7~2^15-1)                     |  16  |  2  |
  int        |  -2,147,483,648 ~ 2,147,483,647(-2^31`~2^31-1,약 ±20억)               |  32   |  4  |
  long       | - 9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807(-2^63~2^63-1)|  64  |  8  |
  float      |            1.4E-45 ~ 3.4E38(1.4 x 10^-45 ~ 3.4 x 10^38)              |  32  |  4  |
  double     |                  4.9E-324 ~ 1.8E308(4.9x10^324 ~ 1.8x10^308)         |  64  |  8  |
  
                           ▲ 표 2-4 기본형의 크기와 범위 
*/
// |참고| float와 double은 양의 범위만 적은 것이다. 음의 범위는 양의 범위에 음수 부호(-)를 붙이면 된다.

// 각 자료형이 가질 수 있는 값의 범위를 정확히 외울 필요는 없고,정수형(byte,short,int,long)의 경우 '-2^n-1 ~ 2^n-1'(n은 bit수)
// 이라는 정도만 기억하고 있으면 된다. 예를 들어 int형의 경우 32bit(4 byte)이므로 '-2^31 ~ 2^31 -1'의 범위를 갖는다.

// 2^10 = 1024 ≒ 10^3 이므로, 2^31 = 2^10 x 2^10 x 2^10 x 2 = 1024 x 1024 x 1024 x2 ≒ 2 x 10^9

// 따라서 int타입의 변수는 대략 10자리 수(약 20억,2,000,000,000)의 값을 저장할 수 있다는 것을 알 수 있다. 
// 7~9자리의 수를 계산할 때는 넉넉하게 long타입(약 19자리)으로 변수를 선언하는 것이 좋다.
// 연산중에 저장범위를 넘어서게 되면 원하지 않는 값을 결과로 얻게 될 것이기 때문이다.
// 실수형은 정수형과 저장형식이 달라서 같은 크기라도 훨씬 큰 값을 표현할 수 있으나 오차가 발생할 수 있다는 단점이 있다.
// 그래서 정밀도(precision)가 중요한데,정밀도가 높을수록 발생할 수 있는 오차의 범위가 줄어든다, 아래의 표른 보면 float의 정밀도는 7자리인데,
// 이것은 10 진수로 7자리의 수를 오차없이 저장할 수 있다는 뜻이다.
/*
   자료형  |                 저장 가능한 값의 범위             | 정밀도   |     크기    | 
  _____________________________________________ _____ _________| bit | byte |
  float  |   1.4E-45 ~ 3.4E38(1,4x10^45 ~ 3.4x10^38)  |  7자리   | 32  |  4   |
 double  |  4.9E-324 ~ 1.8E308(4.9x10^-324~1.8x10^308)| 15자리   | 64  |  8   |

*///                   ▲ 표 2-5 실수형의 범위와 정밀도

// float는 약 ±10^38과 같이 큰 값을 저장할 수 있지만, 정밀도가 7자리 밖에 되지 않으므로 보다 높은 정밀도가 필요한 경우에는 변수의 타입으로
// double을 선택해야한다.이처럼 실수형에서는 저장 가능한 값의 범위뿐만 아니라 정밀도도 타입 선택의 중요한 기준이 된다.

// 2.2 상수와 리터럴(constant & literal)
// '상수(constant)'는 변수와 마찬가지로 '값을 저장할 수 있는 공간'이지만,변수와달리 한 번 값을 저장하면 다른 값으로 변경할 수 없다.
// 상수를 선언하는 방법은 변수와 동일하며,단지 변수의 타잎 앞에 키워드 'final'을 붙여주기만 하면 된다.

//final int MAX_SPEED = 10;  // 상수 MAX_SPEED를 선언 & 초기화 

// 그리고 상수는 반드시 선언과 동시에 초기화해야 하며,그 후 부터는 상수의 값을 변경하는 것이 허용되지 않는다.

// final int MAX_SPEED;        // 에러. 상수는 선언과 동시에 초기화해야함
// final int MAX_VALUE = 100;  // OK. 선언과 동시에 초기화 했음
// MAX_VALUE = 200;            // 에러. 상수의 값은 변경할 수 없음 

// 상수의 이름은 모두 대문자로 하는 것이 암묵적인 관례이며, 여러 단어로 이루어져 있는 경우'_'로 구분한다. 

// |참고| JDK1.6부터 상수를 선언과 동시에 초기화 하지 않아도 되며,사용하기 전에만 초기하하면 되도록 바뀌었다. 
// 그래도 상수는 선언과 동시에 초기화하는 습관을 들이는 것이 좋다.

// 리터럴(literal)
// 원래 12,123,3.14,'A'와 같은 값들이 '상수'인데,프로그래밍에서는 상수를 '값을 한 번 저장하면 변경할 수 없는 저장공간'으로 정의하였기 때문에
// 이와 구분하기 위해 상수를 다른 이름으로 불러야만 했다. 그래서 상수 대신 리터럴이라는 용어를 사용한다. 많은 사람들이 리터럴이라는 용어를 사용한다.
// 많은 사람들이 리터럴이라는 용어를 어려워하는데, 리터럴은 단지 우리가 기존에 알고 있던 '상수'의 다른 이름일 뿐이다.
/*
  변수(variable) 하나의 값을 저장하기 위한 공간 
  상수(constant) 값을 한번만 저장할 수 있는 공간
  리터럴(literal) 그 자체로 값을 의미하는 것
  ____________________________________
   변수            리터럴 
   _↖_    _____↗    ↖
   int year = 2014;     \___        
   final int MAX_VALUE = 100;
       ----↙----- 
          상수 
*/
// 상수가 필요한 이유
// 아마도 이쯤에서 여러분들은'그냥 리터럴을 직접 쓰면 될 텐데,굳이 상수가 따로 필요한가?라는 의문이 들 것도 같다. 먼저 다음의 코드를 보자.
/*
         int triangleArea  = (20 * 10) / 2; // 삼각형의 면적을 구하는 공식 
         int rectangleArea =  20 * 10 ;     // 사각형의 면적을 구하는 공식
 */          
// 위의 코드는 삼각형과 사각형의 면적을 구해서 변수에 저장한다. 이 공식을 모르는 사람은 없겠지만,보다 복잡한 공식이라면 얘기가 달라질 것이다.
// 게다가 20과 10이 아닌 다른 값을 이용해서 결과를 얻고 싶다면 여러 곳을 수정해야한다. 
// 그러면 이제 다음의 코드를 보자

//class Ch02변수의타입{
//	public static void main (String []args) {
//     final int WIDTH  = 20;  //폭
//     final int HEIGHT = 20;  //높이 
//     
//     int triangleArea  = (WIDTH * HEIGHT) / 2;   // 삼각형의 면적을 구하는 공식
//     int rectangleArea = WIDTH * HEIGHT ;        // 사각형의 면적을 구하는 공식 
//     
//     System.out.println(triangleArea);
//     System.out.println(rectangleArea);
//}} 
// 상수를 이용해서 기존의 코드를 변경한 것인데,이전 코드에 비해 면적을 구하는 공식의 의미가 명확해졌다.
// 그리고 다른 값으로 계산할 때도 여러 곳을 수정할 필요없이 상수의 초기화만 다른 값으로 해주면 된다.
// 이처럼 상수는 리터럴에'의미있는 이름'을 붙여서 코드의 이해와 수정을 쉽게 만든다.

// 리터럴의 타입과 접미사
// 변수에 타입이 있는 것처럼 리터럴에도 타입이 있다.변수의 타입은 저장될 '값의 타입(리터럴의 타입)'에 의해 결정되므로,
//만일 리터럴에 타입이 없다면 변수의 타입도 필요없을 것이다
/*
    종류    |          리터럴              |   접미사  |
   논리형    |         flase,true         |   없음   |
   정수형    |  123,0b0101,077,0xFF,100L  |   L     |
   실수형    |  3.14, 3.0e8 1.4f, 0x1,0p-1|   f,d   |
   문자형    |  'A','1','\n'              |   없음    |
   문자열    |  "ABC","123","A","true"    |   없음    |

             ▲ 표 2-6 리터럴과 접미사 
*/
 
 
