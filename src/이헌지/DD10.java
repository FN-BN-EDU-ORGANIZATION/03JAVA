package 이헌지;

//정수형과 실수형에는 여러 타입이 존재하므로,리터럴에 접미사를 붙여서 타입을 구분한다. 정수형의 경우,long타입의 리터럴에 접미사'l'또는 'L'을 붙이고,
//접미사가 없으면 int 타입의 리터럴이다. byte와 short타입의 리터럴은 별도로 존재하지 않으며 byte와 short타입의 변수에 값을 저장할 때는
//int타입의 리터럴을 사용한다. 
//10진수 외에도 2,8,16 진수로 표현된 리터럴을 변수에 저장할 수 있으며,16진수라는 것을 표시하기 위해 리터럴 앞에 접두사'0x'또는 '0x'를
//8진수의 경우에는 '0'을 붙인다.

//|참고| 접두사'0x','0X','0b','0'은 알파벳이 아니라 숫자이다.2진 리터럴은 JDK 1.7부터 추가 되었다.
/*
 int outNum = 010;        //  8진수 10, 10진수로 8
 int hexNum = 0x10;       // 16진수 10, 10진수로 16
 int binNUm = 0b10;       //  2진수 10, 10진수로 2
*/
//그리고 JDK1.7부터 정수형 리터럴의 중간에 구분자 '_'를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있게 되었다.
/* 
 long big = 100_000_000_000L;        // long big = 100000000000L;
 long hex = 0xFFFF_FFFF_FFFF_FFFFL;  // long hex = 0xFFFFFFFFFFFFFFFFL;
*/
//실수형에서는 float타입의 리터럴에 접미사 'f'또는'F'를 붙이고,double타입의 리터럴에는 접미사'd'또는'D'를 붙인다.
/*
 float pi     = 3.14f           // 접미사 f 대신 F를 사용해도 된다.
 double rate  = 1.618;          // 접미사 d 대신 D를 사용해도 된다.
*/
//실수형 리터럴에는 접미사를 붙여서 타입을 구분하며,float타입 리터럴에는'f'를,double타입 리터럴에는 'd'를 붙인다.
//정수형에서는 int가 기본 자료형인 것처럼 실수형에서는 double이 기본자료형이라서 접미사 'd'는 생략이 가능하다.
//실수형 리터럴인데,잡미사가 없으면 double타입 리터럴인 것이다.
/*
 float pi    = 3.14;   //에러.float타입 변수에 double타입 리터럴 저장불가
 double rate = 1.618;  //OK. 접미사 d는 생략할 수 있다.
*/
//위의 문장에서 3.14는 접미사가 붙지 않앗으므로 float타입 리터럴이 아니라 double타입 리터럴로 간주된다.
//그래서 3.14가 float타입의 범위에 속한 값임에도 불구하고 컴파일 시에 에러가 발생한다. 에러를 피하려면 3.14f와 같이 접미사를 붙여야 한다.
//리터럴의 접두사와 접미사는 대소문자를 구별하지 않으므로,대문자와 소문자 중에서 어떤 것을 사용해도 상관없지만,소문자'l'과 헷갈리기 쉬우므로 
//대문자인 'L'을 사용하는 것 이 좋다.

//|참고| 리터럴에 접미사가 붙는 타입은 long,float,double뿐인데,double은 생략가능하므로 long과 float의 리터럴에 접미사를 붙이는 것만
//신경쓰면 된다.

//리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e,그리고 접미사 f,F,d,D를 포함하고 있으면 실수형 리터럴로 간주된다.
/*
  자료형      |     실수형 리터럴      | 다른 형태의 동등한 표현 | 
 double     |        10.         |    10.0         |
 double     |       .10          |    0.10         | 
  float     |        10f         |    10.0f        |
  float     |      3.14e3f       |   3140.0f       |
 double     |        lel         |    10.0         |
 double     |       le-3         |    0.001        |
      
           ▲ 표 2-8 실수형 리터럴의 예
*/
//참고로 잘 쓰이지는 않지만 기호 p를 이용해서 실수 리터럴을 16진 지수형태로 표현할 수 도 있다.
//p는 2의 제곱을 의미하며,p의 왼쪽에는 16진수를 적고 오른쪽에는 지수를 10진 정수로 적는다.
//p는 대소문자 모두 가능하며,p가 포함된 리터럴은 실수형이다.
/*
 0x1p1    =(1x16^0)x2^1          = 10 x 2      = 2.0
 0x0.2p-1 =(2x16^-1)x2^-1        = 0.125 x 0.5 = 0.0625
 0x12p3   =(1x16^1+ 2 x 16^0) x2 =(16+2) x 8 144.0
*/
//타입의 불일치
//리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만,타입이 달라도 저장범위가 넣음 타입에 좁은 타입의 값을 저장하는 것은 허용된다.
/*  
 int    i = 'A';      // OK. 문자 'A'의 유니코드인 65가 변수 i에 저장된다.
 long   i = 123;      // OK. int보다 long타입이 더 범위가 넒다.
 double d = 3.14f     // OK. float보다 double타입이 더 범위가 넒다.
*/
//그러나 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장범위가 넒으면 컴파일 에러가 발생한다.
/* 
 int    i  = 0x123456789;   // 에러. int타입의 범위를 넘는 값을 저장
 float  f  = 3.14;          // 에러. float타입보다 double타입의 범위가 넒다.
*/
//3.14는 3.14d에서 접미사가 생략된 것으로 double타입이다. 이 값을 float타입으로 표현할 수 있지만,
//double타입의 리터럴이므로 float타입의 변수에 저장할 수는 없다.

//|참고| float는 접미사나 정밀도 등 신경 쓸 것이 많다. 이런 것들이 귀찮다면 그냥 double을 사용하자.

//byte와 short타입의 리터럴은 따로 존재하지 않으므로 int타입의 리터럴을 사용한다. 단,short타입의 변수가 저장할 수 있는 범위에 속한 것이여야 한다.
/*
 byte  b = 65;        //OK. byte타입에 저장 가능한 범위의 int타입 리터럴
 short s = 0x1234;    //OK. short타입에 저장 가능한 범위의 int타입 리터럴
*/
//각 타입의 저장범위만 알아도 충분히 판단가능한 내용이다. 값의 크기에 상관없이 double 타입의 리터럴을 float타입의 변수에 저장할 수 없다는 것만 주의하자.
//보다 자세한 내용은 이장의 마지막 단원인'형변환'에서 설명한다.
