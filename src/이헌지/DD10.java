package 이헌지;

//정수형과 실수형에는 여러 타입이 존재하므로,리터럴에 접미사를 붙여서 타입을 구분한다. 정수형의 경우,long타입의 리터럴에 접미사'l'또는 'L'을 붙이고,
//접미사가 없으면 int 타입의 리터럴이다. byte와 short타입의 리터럴은 별도로 존재하지 않으며 byte와 short타입의 변수에 값을 저장할 때는
//int타입의 리터럴을 사용한다. 
//10진수 외에도 2,8,16 진수로 표현된 리터럴을 변수에 저장할 수 있으며,16진수라는 것을 표시하기 위해 리터럴 앞에 접두사'0x'또는 '0x'를
//8진수의 경우에는 '0'을 붙인다.

//|참고| 접두사'0x','0X','0b','0'은 알파벳이 아니라 숫자이다.2진 리터럴은 JDK 1.7부터 추가 되었다.
/*
 int outNum = 010;        //  8진수 10, 10진수로 8
 int hexNum = 0x10;       // 16진수 10, 10진수로 16
 int binNUm = 0b10;       //  2진수 10, 10진수로 2
*/
//그리고 JDK1.7부터 정수형 리터럴의 중간에 구분자 '_'를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있게 되었다.
/* 
 long big = 100_000_000_000L;        // long big = 100000000000L;
 long hex = 0xFFFF_FFFF_FFFF_FFFFL;  // long hex = 0xFFFFFFFFFFFFFFFFL;
*/
//실수형에서는 float타입의 리터럴에 접미사 'f'또는'F'를 붙이고,double타입의 리터럴에는 접미사'd'또는'D'를 붙인다.
/*
 float pi     = 3.14f           // 접미사 f 대신 F를 사용해도 된다.
 double rate  = 1.618;          // 접미사 d 대신 D를 사용해도 된다.
*/
//실수형 리터럴에는 접미사를 붙여서 타입을 구분하며,float타입 리터럴에는'f'를,double타입 리터럴에는 'd'를 붙인다.
//정수형에서는 int가 기본 자료형인 것처럼 실수형에서는 double이 기본자료형이라서 접미사 'd'는 생략이 가능하다.
//실수형 리터럴인데,잡미사가 없으면 double타입 리터럴인 것이다.
/*
 float pi    = 3.14;   //에러.float타입 변수에 double타입 리터럴 저장불가
 double rate = 1.618;  //OK. 접미사 d는 생략할 수 있다.
*/
//위의 문장에서 3.14는 접미사가 붙지 않앗으므로 float타입 리터럴이 아니라 double타입 리터럴로 간주된다.
//그래서 3.14가 float타입의 범위에 속한 값임에도 불구하고 컴파일 시에 에러가 발생한다. 에러를 피하려면 3.14f와 같이 접미사를 붙여야 한다.
//리터럴의 접두사와 접미사는 대소문자를 구별하지 않으므로,대문자와 소문자 중에서 어떤 것을 사용해도 상관없지만,소문자'l'과 헷갈리기 쉬우므로 
//대문자인 'L'을 사용하는 것 이 좋다.

//|참고| 리터럴에 접미사가 붙는 타입은 long,float,double뿐인데,double은 생략가능하므로 long과 float의 리터럴에 접미사를 붙이는 것만
//신경쓰면 된다.

//리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e,그리고 접미사 f,F,d,D를 포함하고 있으면 실수형 리터럴로 간주된다.
/*
  자료형      |     실수형 리터럴      | 다른 형태의 동등한 표현 | 
 double     |        10.         |    10.0         |
 double     |       .10          |    0.10         | 
  float     |        10f         |    10.0f        |
  float     |      3.14e3f       |   3140.0f       |
 double     |        lel         |    10.0         |
 double     |       le-3         |    0.001        |
      
           ▲ 표 2-8 실수형 리터럴의 예
*/
//참고로 잘 쓰이지는 않지만 기호 p를 이용해서 실수 리터럴을 16진 지수형태로 표현할 수 도 있다.
//p는 2의 제곱을 의미하며,p의 왼쪽에는 16진수를 적고 오른쪽에는 지수를 10진 정수로 적는다.
//p는 대소문자 모두 가능하며,p가 포함된 리터럴은 실수형이다.
/*
 0x1p1    =(1x16^0)x2^1          = 10 x 2      = 2.0
 0x0.2p-1 =(2x16^-1)x2^-1        = 0.125 x 0.5 = 0.0625
 0x12p3   =(1x16^1+ 2 x 16^0) x2 =(16+2) x 8 144.0
*/
//타입의 불일치
//리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만,타입이 달라도 저장범위가 넣음 타입에 좁은 타입의 값을 저장하는 것은 허용된다.
/*  
 int    i = 'A';      // OK. 문자 'A'의 유니코드인 65가 변수 i에 저장된다.
 long   i = 123;      // OK. int보다 long타입이 더 범위가 넒다.
 double d = 3.14f     // OK. float보다 double타입이 더 범위가 넒다.
*/
//그러나 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장범위가 넒으면 컴파일 에러가 발생한다.
/* 
 int    i  = 0x123456789;   // 에러. int타입의 범위를 넘는 값을 저장
 float  f  = 3.14;          // 에러. float타입보다 double타입의 범위가 넒다.
*/
//3.14는 3.14d에서 접미사가 생략된 것으로 double타입이다. 이 값을 float타입으로 표현할 수 있지만,
//double타입의 리터럴이므로 float타입의 변수에 저장할 수는 없다.

//|참고| float는 접미사나 정밀도 등 신경 쓸 것이 많다. 이런 것들이 귀찮다면 그냥 double을 사용하자.

//byte와 short타입의 리터럴은 따로 존재하지 않으므로 int타입의 리터럴을 사용한다. 단,short타입의 변수가 저장할 수 있는 범위에 속한 것이여야 한다.
/*
 byte  b = 65;        //OK. byte타입에 저장 가능한 범위의 int타입 리터럴
 short s = 0x1234;    //OK. short타입에 저장 가능한 범위의 int타입 리터럴
*/
//각 타입의 저장범위만 알아도 충분히 판단가능한 내용이다. 값의 크기에 상관없이 double 타입의 리터럴을 float타입의 변수에 저장할 수 없다는 것만 주의하자.
//보다 자세한 내용은 이장의 마지막 단원인'형변환'에서 설명한다.

//문자 리터럴과 문자열 리터럴 
//'A'와 같이 작은따옴표로 문자 하나를 감싼 것을 '문자 리터럴'이라고 한다. 두 문자 이상은 큰 따옴표로 감싸야 하면 '문자열 리터럴'이라고 한다.

//|참고| 문자열은 '문자의 연속된 나열'이라는 뜻이면,영어로'string'이라고 한다.
/*
 char   ch   = 'J';         // char ch = 'Java'; 이렇게 할 수 없다.
 String name = "Java";      // 변수 name에 문자열 리터럴 "Java"를 저장
*/
//char타입의 변수는 단 하나의 문자만 저장할 수 있으므로, 여러 문자(문자열)를 저장하기 위해서는 String타입을 사용해야 한다.
//문자열 리터럴은 ""안에 아무런 문자도 넣지 않는 것을 허용하며, 이를 빈 문자열(empty string)이라고 한다.
//그러나 문자 리터럴은 반드시 ''안에 하나의 문자가 있어야한다.
/*
 String str = "";  // OK. 내용이 없는 빈 문자열
 Char   ch  = '';  // 에러. ''안에 반드시 하나의 문자가 필요
 char   ch  = ' '; // OK. 공백 문자(blank)로 변수 ch를 초기화
*/
//원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히 위와 같은 표현도 허용한다.
/* 
 String name = new String("Java");   // String객체를 생성 
*/
//그리고 덧셈 연산자를 이용하여 문자열을 결합할 수 있어서 다음과 같이 할 수 있다.
/*
 String name = "Ja" + "va";  // name은 "Java"
 String str  = name + 8.0;   // str은 "Java8.0"
*/
//덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음
//두 String을 결합한다. 기본형과 참조형의 구별 없이 어떤 타입의 변수도 문자열과 덧셈연산을 수행하면 그 결과가 문자열이 되는 것이다.
/*
 문자열 + any type → 문자열 + 문자열 → 문자열
 any type + 문자열 → 문자열 + 문자열 → 문자열
*/
//예를 들어 7+"7"을 계산할 때 7이 String이 아니므로,먼저 7을 String으로 변환한 다음 
//"7"+"7"을 수행하여 "77"을 결과로 얻는다.다음은 문자열 결합의 몇가지 예를 보여준다.
/*
 7 + " " → "7" + " "  → "7 "
 " " + 7 → " " + "7:" → " 7"
 
 7 + 7 + "" → 14 + "" → "14" + "" → "14"
 "" + 7 + 7 → "7"+ 7  → "7"  +"7" → "77"
 
 true + "" → "true" + "" → "true"
 null + "" → "null" + "" → "null"
*/
//덧셈 연산자는 왼쪽에서 오른쪽의 방향으로 연산을 수행하기 때문에 결합순소에 따라 결과가 달라진다는 것에 주의하자,
//그리고 7과 같은 기본형 타입의 값을 문자열로 변환할 때는 아무런 내용도 없는 빈 문자열("")을 더해주면 된다는 것도 알아두자.

//public class Ch02변수의타입{
//	public static void main (String[]args) {
//		String name = "Ja" + "va";
//		String str  = name + 8.0;
//		
//		System.out.println(name);
//		System.out.println(str);
//		System.out.println(7 + " ");
//		System.out.println(" " + 7);
//		System.out.println(7 + "");
//		System.out.println("" + 7);
//		System.out.println("" + "");
//		System.out.println(7 + 7 + "");
//		System.out.println("" + 7 + 7);
//	}
//}