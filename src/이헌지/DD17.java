package 이헌지;

package C023진법;

//3.6 음수의 2진 표현 - 2의 보수법

//앞서 살펴본 것과 같이 n비트의 2진수로 표현할 수 있는 값의 개수는 모두 2^n개 이므로,4비트의 2진수로는 모두 2^4(=16)개의
//값을 표현할 수 있었다. 이 값을 모두 '부호없는 정수(0과 양수)'의 표현에 사용하면,아래와 같이 '0부터 15까지의 정수'를 나타낼 수 있다.
/*
             #    | 2진수 | 부호없는 10진수|
           1    | 0000 | 최소값 -> 0  |    
           2    | 0001 |         1  |    
           3    | 0010 |         2  |    
           4    | 0011 |         3  |    
           5    | 0100 |         4  |    
           6    | 0101 |         5  |    
           7    | 0110 |         6  |    
           8    | 0111 |         7  |    
           9    | 1000 |         8  |            
          10    | 1001 |         9  |    
          11    | 1010 |        10  |    
          12    | 1011 |        11  |    
          13    | 1100 |        12  |    
          14    | 1101 |        13  |    
          15    | 1110 |        14  |    
          16    | 1111 |        15  |    

        ▲ 표 2-10 4비트로 표현할 수 있는 부호없는 10진 정수
*/
//그러면 4비트의 2진수로 부호있는 정수,즉 양수와 음수를 모두 표현하려면 어떻게 해야할까? 4비트 2진수의 절반인 8개는 0으로 시작하고,
//나머지 절반을 1로 시작하니까,1로 시작하는 2진수를 음수표현에 사용하자. 이렇게 하면 '왼쪽의 첫 번쨰 비트(MSB)'가 0이면 양수,
//1이면 음수이므로 첫 번째 비트만으로 값의 부로흘 알 수 있게 된다.

//|참고| 2진수의 제일 왼쪽의 1bit를 MSB(most singificant bit)'라고 한다.
/*            
           #    | 2진수 | 부호없는 10진수|
           1    | 0000 | 최소값 -> 0  |    
           2    | 0001 |         1  |    
           3    | 0010 |         2  |    
           4    | 0011 |         3  |    
           5    | 0100 |         4  |    
           6    | 0101 |         5  |    
           7    | 0110 |         6  |    
           8    | 0111 |         7  |    
           9    | 1000 |       ???  |            
          10    | 1001 |       ???  |    
          11    | 1010 |       ???  |    
          12    | 1011 |       ???  |    
          13    | 1100 |       ???  |    
          14    | 1101 |       ???  |    
          15    | 1110 |       ???  |    
          16    | 1111 |       ???  |     
*/
//이제 위 표의 절반을 어떻게 음수로 채워야할까> 일단 양수처럼 0부터 순차적으로 채워보자. 
/*            
         #    | 2진수 | 부호없는 10진수|
         1    | 0000 | 최소값 -> 0  |    
         2    | 0001 |         1  |    
         3    | 0010 |         2  |    
         4    | 0011 |         3  |    
         5    | 0100 |         4  |       | 0|1|0|1 ← 10진수로  5
         6    | 0101 |         5  |       | 1|1|0|1 ← 10진수로 -5
	 	    7    | 0110 |         6  |    -----------------------
	 	    8    | 0111 | 최소값 ->  7  |    1  |0|1|1|0| ← 자리올림이 발생했으나 크기가 4비트라서 버려짐
	        9    | 1000 |        -0  |            
	 	   10    | 1001 |        -1  |    
		   11    | 1010 |        -2  |    
		   12    | 1011 |        -3  |    
		   13    | 1100 |        -4  |    
		   14    | 1101 |        -5  |    
		   15    | 1110 |        -6  |    
		   16    | 1111 |        -7  |     
*/
//음수를 이렇게 배치하면,양수의 첫 번째 비트만 1로 바꾸면 음수가 된다는 장점이 있다.
//그러나, 두 수를 더했을 때 2진수로 0이 되지 않는다는 것과 0이 두개(0,-0)존재한다는 단점이 있다.
//게다가 2진수가 증가할 때 10진 음수는 감소한다.
/*
                  #    | 2진수 | 부호없는 10진수|
         1    | 0000 | 최소값 -> 0  |    
         2    | 0001 |         1  |    
         3    | 0010 |         2  |    
         4    | 0011 |         3  |    
         5    | 0100 |         4  |        |0|1|0|1 ← 10진수로  5
         6    | 0101 |         5  |        |1|1|0|1 ← 10진수로 -5
	 	    7    | 0110 |         6  |     -----------------------
	 	    8    | 0111 | 최소값 ->  7  |--    1 |0|1|1|0| ← 자리올림이 발생했으나 크기가 4비트라서 버려짐
	        9    | 1000 |        -8  |  |          
	 	   10    | 1001 |        -7  |  |  
		   11    | 1010 |        -6  |  |  
		   12    | 1011 |        -5  |   → 2의 보수법에 의한 음수배치  
		   13    | 1100 |        -4  |  |  
		   14    | 1101 |        -3  |  |  
		   15    | 1110 |        -2  |  |  
		   16    | 1111 |        -1  |--    
*/
//그러나 위와 같이 '2의 보수법'에 의해 음수를 배치하면,절대값이 같은 양수와 음수를 더했을 때 2진수로도 0을 결과로 얻으므로
//부호를 신경쓰지 않고 덧셈할 수 있게 된다. 그리고 2진수가 증가할 때 10진 음수가 감소한다는 모순도 없어졌다.
//다만,첫 번째 비트를 바꾸는 것만으로 값의 부호를 바꿀 수 없게 되었다.

//2의 보수법 

//어떤 수의'n의 보수'는 더했을 때 n이 되는 수를 말한다. 7의 '10의 보수'는 3이고, 3이 '10의 보수'는 7이다.
//3과 7은 '10의 보수의 관계'에 있다고 한다'2의 보수 관계' 역시,더해서 2가 되는 두 수의 관계를 말하며
//10진수 2는 2진수로'10'이다. 2진수로 '10'은 자리올림이 발생하고 0이 되는 수를 말한다.
//그래서 '2의 보수 관계'에 있는 두 2진수를 더하면'(자리올림이 발생하고)0이 된다.'
/*
          |0|1|0|1|   ← 10진수로  5
        +)|1|0|1|1|   ← 10진수로 -5
       ------------ 
        1 |0|0|0|0|   ← 자리올림이 발생했으나 크기가 4비트라 버려짐     
*/
//위의 그림에서 알 수 있듯이 2진수 '0101'와 같이 '1011'은 서로 '2의 보수 관계'에 있으며,이 두 2진수를 더하면 0이 된다.
//이 덧셈이 10진수로도 0이 되려면,2진수 '0101'가 10진수로 5니까,2진수'1011'은 10진수로 -5 이어야 한다.
/*
               2진수 |부호있는 10진수|
               0000|          0|
               0001|          1|
               0010|          2|
               0011|          3|
               0100|          4|
       --------0101|          5|-------
       |       0110|          6|       |
       |       0111|          7|       | 
   2의 보수 관계   1000|         -8|    부호가 다르고 
       |       1001|         -7|   절대값이 같은 수
       |       1010|         -6|       |
       -------1011|          -5|-------|
               1100|         -4|
               1101|         -3|
               1110|         -2|
               1111|         -1|
*/
//이처럼 서로 '2의 보수 관계'에 있는 두2진수로 5와 -5처럼 절대값이 같고 부호가 다른 두10진수를 표현하는 것을 '2의 보수법'
//이라고 하며,현재 대부분의 시스템이 '2의 보수법'으로 부호있는 정수를 표현한다.

//음수를 2진수로 표현하기 
//10진 음의 정수를 2진수로 변환하려면, 먼저 10진 음의 정수의 절대값을 2진수로 변환한다. 
//그 다음에 이 2진수의 '2의 보수'를 구하면 된다. 예를 들어'-5'의 2진 표현을 구하는 과정은 다음과 같다.
/*
                 1.절대값        2. 2진수         3. 2의 보수
          -5(10) -------> 5(10)------->0101(2)---------> 1011(2)
*/
//위의 방법은 부호가 다르고 절대값이 같은 두 정수의 2진 표현이 서로 '2의 보수'관계에 있다는 것을 이용한 것으로 복잡해 보이지만 간단하다.
//절대값은 부호만 떼어내면 되고,10진수를 2진수로 변환하는 방법은 이미 배웠고,'2의 보수'로 변환하는 방법도 쉽다.

//2의 보수 구하기

//서로 '2의 보수'의 관계에 있는 두 수를 더하면 '0(자리올림 발생)'이 된다. 
//예를 들어 2진수 '0101'의 '2의 보수'를 구하려면,'0101'에 어떤 수를 더하면 0이 되는지 알아내야 한다.
/*
         |0|1|0|1|+|?|?|?|?|= 1|0|0|0|0|
                     2의 보수             
*/
//아래와 같이 뺄셈으로 '2의 보수'를 간단히 구할 수 있지만 자리수가 많아지면 뺄셈도 쉽지 않다.
/*
        1|0|0|0|0| - |0|1|0|1| = |1|0|1|1| 
                                   2의 보수  
*/
//다행이 뺄셈보다 '2의 보수'를 더 간단히 구하는 방법이 있다. '1의 보수'를 구한 다음 1을 더한다. 그러면,2의 보수를 구할 수 있다.
/*
                       2의 보수 = 1의 보수 + 1
*/
//'1의 보수'는 0을 1로,1을 0으로만 바꾸면 되르모 구하기 쉽다. 
//예를 들어,2진수 '0101'의 '1의 보수'는 '1010'이다. 여기에 1을 더하기만 하면 2의 보수가 된다.
/*
                   |0|1|0|1|
                    ↓ ↓ ↓ ↓ 
                   |1|0}1|0|    ← '0101'의  '1의보수'
                 +)       1     
                ____________
                   |1|0|1|1|    ← '0101'의  '2의 보수'
*/
//왜'1의 보수 +1'은'2의 보수'인가?
//어떤 2진수가 있을 때,이 2진수의 1의 보수를 더하면 모든 자리가 1이 된다.
/*
          |0|1|0|1|  +  |1|0|1|0|  =  |1|1|1|1| 
                    '0101'의 '1의 보수'
*/
//위의 식에서 양변에 1을 더하면 우변은 0이 된다. 올림(carry)이 발생하지만 4비트를 넘는 값이라 저장할 공간이 없어서 버려진다.
/*
         |0|1|0|1| + |1|0|1|0| + 1 = |1|1|1|1| + 1
         |0|1|0|1| +(|1|0|1|0| + 1)= |1|1|1|1| + 1
                    _______________
                      1의 보수 + 1 
*/
//위의 식에서 알 수 있듯이 어떤 수에'1의 보수 +1'을 더하면 0이 되므로 '1의 보수+1'은'2의 보수'와 같다는 것이 증명된다.
/*
                 |?|?|?|?| +   1의 보수   =  |1|1|1|1| 
                 |?|?|?|?| + (1의 보수+1) = 1|0|0|0|0| 
                 |?|?|?|?| +   2의 보수   = 1|0|0|0|0| 
                  ∴ 2의 보수 = 1의 보수 +1

지금까지 길게 설명 했는데 다 이해하지 못해도 괜찮다. 아래의 내용만 확실히 기억하자 

음수의 2진 표현을 구하는 방법

(1)음수의 절대값을 2진수로 변환한다.
 :-5의 절대값인 5를 2진수로 변환한다. 10진수 5를 2진수로 변환하면 '0101'이다.

(2)(1)에서 구한 2진수의 1을 0으로 0은 1로 바꾼다.(1의 보수 구하기)
 :'0101'이 '1010'이 된다.
 
(3)(2)의 결과에 1을 더한다.(2의 보수 구하기,1의 보수 +1)
:'1010'에 1을 더하면 '1011'이 되고,이것이 -5의 2진 표현이다.

*/ 




