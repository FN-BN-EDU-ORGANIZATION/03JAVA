package 이헌지;

//4.3 정수형 - byte,short,int,long

//정수형에는 모두 4개의 자료형이 있으며,각 자료형이 저장할 수 있는 값의 범위가 서로 다르다.
//크기순으로 나열하면 다음과 같다. 단위는 byte이다.
/*
   byte <  short  <  int  <  long
     1       2        4        8   
*/ 
//정수형의 표현형식과 범위
//어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다.이 2진수가 저장되는 형식은 크게 정수형과 실수형이 있으며,
//정수형은 다음과 같은 형식으로 저장된다.
/*
             |s|       n-1 bit      |
             S: 부호 비트(양수는 0,음수는 1)
             N: 타입의 크기(단위:bit)
             
             ▲ 그림2-10 정수형의 표현방식
*/
//모든 정수형은 부호있는 정수이므로 왼쪽의 첫 번째 비트를'부호 비트(sign bit)'로 사용하고,나머지는 값을 표현하는데 사용한다.
//그래서 n비트로 표현할 수 있는 값의 개수인 2^n개에서, 절반인'0'으로 시작하는 '2^n-1개의 값을 양수(0도 포함)의 표현에 
//사용하고,나머지 절반이'1'로 시작하는 2^n-1개의 값은 음수의 표현에 사용한다.
/*
   |        정수형의 표현형식(n bit)      |     종류     |   값의 개수  |
   |0|      n-1 bit                 |   0,양수     |  2^n-1개   |
   |1|      n-1 bit                 |     음수     |  2^n-1개   |
*/
//그래서 정수형은 타입의 크기만 알면,최대값과 최소값을 쉽게 계산해낼 수 있다.
/*
            n비트로 표현할 수 있는 정수의 개수 : 2^n-1개 + 2^n-1개)
            n비트로 표현할 수 있는 부호있는 정수의 개수 : 2^n-1 ~ 2^n-1 -1
            
           -2^n-1                         2^n-1 -1  
         <------------- 부호있는 정수(2^n개) ------------>
                             ↓   
                             0
*/
//위의 범위의 최대값에서 1을 빼는 이유는 범위에 0이 포함되기 때문이다.예를 들어 byte의 경우 크기가 1byte(=8 bit)이므로,
//byte타입의 변수에 저장할 수 있는 값의 범위는 '-128 ~ 127'이다.
/* 
   |               byte의 표현형식(8 비트)     |    종류    |   값의 개수     |
   ||0|0|0|0|0|0|0|0| ~ |0|1|1|1|1|1|1|1| |   0,양수   |  2^7(0~127)  |
   ||1|0|0|0|0|0|0|0| ~ |1|1|1|1|1|1|1|1| |    종류    |  2^7(-128~-1)|
   
   8비트로 표현할 수 있는 정수의 개수: 2^8개(= 2^7개 + 2^7개)
   8비트로 표현할 수 있는 부호있는 정수의 개수: -2^7 ~ 2^7 -1(-128 ~ 127)
   
     -128(=-2^7)                        127(=2^7-1)  
         <------------- byte의 범위(2^8개 = 256개) ------------>
                             ↓   
                             0
   이처럼 타입의 크기만 알면,모든 정수형의 표현범위를 쉽게 계산해낼 수 있다.

                                                                                      크기
|  타입  |                                                                        |bit|byte|  
| byte  |                         -128 ~ 127(-2^7`2^7-1)                         | 8 | 1 | 
| short |                     -32,768 ~ 32,767(-2^15 ~ 2^15 -1                   |16 | 2 | 
| int   |         - 2,147,483,648 ~ 2,147,483,647(-2^31 ~ 2^31 -1,약 ± 20억)       |32 | 4 | 
| long  | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807(-2^63 ~ 2^63 -1) |64 | 8 |     

                                   ▲ 정수형의 표현범위
*/
//정수형의 선택기준

//변수에 저장하려는 정수값의 범위에 따라 4개의 정수형 중에서 하나를 서택하면 되겠지만, byte나 short보다 int를 사용하도록 하자.
//byte와 short이 int보다 크기가 작아서 메모리를 조금 더 절약할 수는 있지는,저장할 수 있는 값의 범위가 작은 편이라서 연산 
//시에 범위를 넘어서 잘못된 결과를 얻기가 쉽다.
//그리고 JVM의 피연산자 스택(oprerand stack)이 피연산자를 4 byte 단위로 저장하기 때문에 크기가 4byte보다 작은 자료형
//(byte,short)의 값을 계산할 때는 4 byte 로 변환하여 연산이 수행된다. 그래서 오히려 int를 사용하는 것이 효율적이다.
//int타입의 크기는 4byte(=32 bit)이므로,표현할 수 있는 있는 정수의 개수는'2^32 ≒ 4x10^9,약 40억 이며,
//표현가능의 정수으 범위는 '-2^31 ~ 2^31 -1≒±20억'이다.

//2^10 = 1024 ≒ 10^3 이므로, 2^32 = 2^10 x 2^10 x 2^10 x 2^2 = 1024 x 1024 x1024 x 4 ≒ 10^9

//결론적으로 정수형 변수를 선언할 때는 int타입으로 하고,int의 범위(약 ±20억)를 넘어서는 수를 다뤄야할 때는 long을 사용하면 된다.
//그리고 byte나 short은 성능보다 저장공간을 절약하는 것이 더 중요할 때 사용하자.

//| 참고 | long타입의 범위를 벗어나는 값을 다룰 때는,실수형 타입이나 BigInteget클래스(p.518)를 사용하면 된다.

//정수형의 오버플로우
//만일 4 bit 2진수의 최대값인 '1111'에 1을 더하면 어떤 결과를 얻을까? 4 bit의 범위를 넘어서는 값이 되기 때문에 에러가 발생할까>
/*
                |1|1|1|1|
              +)|0|0|0|1|
              ___________
                |?|?|?|?|
*/
//원래 2진수 '1111'을 더하면 '10000'이 되지만,4 bit로는 4자리의 2진수만 저장할 수 있기 때문에 '0000' 이 된다.
//즉,5자리의 2진수 '10000'중에서 하위 4 bit만 저장하게 되는 것이다.
//이처럼 연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)라고 한다.
//오버플로우 가 발생했다고 해서 에러가 발생하는 것은 아니다.
//다만 예상헀던 결과를 얻지 못할 뿐이다. 애초부터 오버플로우가 발생하지 않게 충분한 크기의 타입을 선택해서 사용해야 한다.
/* 
               10진수                                       2진수               
             |9|9|9|9|                                  |1|1|1|1|
           +)       1   ←    저장할 공간이                 +)       1
           ___________    없어서 1은 버려짐 →                ___________
           1 |0|0|0|0|                                 1 |0|0|0|0|
                        ▲ 4자리의 10진수와 2진수의 오버플로우 
*/         
//오버플로우 '자동차 주행표시기(odometer)'나.'계수기(counter)'등 우리의 일상생활에서도 발견할 수 있는데,
//네 자리 계수기라면'0000'부터'9999'까지 밖에 표현하지 못하므로 최대값인'9999'다음의 숫자는 '0000'이 될 것이다.
//원래는 10000이 되어야하는데 다섯 자리는 표현할 수 없어서 맨 앞의 1은 버려지기 때문이다.
//그러면 이번엔 반대로 최소값인 '0000'에서 1을 감소시키면 어떤 결과를 얻을까? 0에서  
//1을 뺄 수 없으므로 '0000'앞에 저장되지 않은 1이 있다고 가정하고 뺄셈이 한다. 
//결과는 아래와 같이 네 자리로 표현할 수 있는 최대값이 된다. 

/*
             10진수                                   2진수 

           1|0|0|0|0|    ← 저장되지 않은              1|0|0|0|0|
          -)       1       1이 있다고 가정 →        -)        1  
           ___________                           ___________
            |9|9|9|9|                              |1|1|1|1|
*/
//이는 마치 계수기를 거꾸로 돌리는 것과 같다.'0000'에서 정방향으로 돌리면 '0001'이 되지만 역방향으로 돌리면'9999'가 되는 것이다.
//| 참고 | TV의 채널을 증가시키다가 마지막 채널에서 채널을 더 증가시키면 첫 번째 채널로 이동하고,첫번째 채널에서 채널을 감소시키면
//마지막 채널로 이동하는 것과 유사하다.

//그래서 정수형 타입이 표현할 수 있는 최대값에 1을 더하면 최소값이 되고,최소값에서 1을 뺴면 최대값이 된다.

//                      최대값 + 1 → 최소값
//                      최소값 - 1 → 최대값

//아래 그림과 같이 최소값과 최대값을 이어 놓았다고 생각하면 생각하면 오버플로우의 결과를 더 이해하기 쉽다.
/*
        최대값   →   9999        ...
                   9998    ▲  0002              9999 + 1 → 0000
                   9997  →    0001              최대값        최소값
                   ...     ▼  0000      ← 최소값
                   0003       9999      
                   0002       9998      ← 최대값
                   0001       9997               0000 - 1 → 9999
        최소값   →    0000        ...               최소값        최대값           
*/ 
//위의 그림을 2진수로 바꾸면 다음과 같다.
/*
       최대값   →   1111        ...
                  1110    ▲  0010              1111 + 1 → 0000
                  1101  →    0001              최대값        최소값
                  ...     ▼  0000      ← 최소값
                  0003       1111      
                  0002       1110      ← 최대값
                  0001       1101              0000 - 1 → 1111
      최소값   →    0000        ...               최소값        최대값          

*/
//4 bit 2진수의 최소값이 '0000'부터 시작해서 1씩 계속 증가하다 최대값인 '1111'을 넘으면 다시 '0000'이 된다.
//그래서 값을 무한히 1씩 증가시켜도'0000'과 '1111'의 범위를 계속 반복하게 된다.